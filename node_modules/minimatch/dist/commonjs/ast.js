"use strict";
// parse a single path portion
Object.defineProperty(exports, "__esModule", { value: true });
exports.AST = void 0;
const brace_expressions_js_1 = require("./brace-expressions.js");
const unescape_js_1 = require("./unescape.js");
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to prot272C8 ³Ð1A1AE6Bÿ¿2¿2¿2¿2¿2¿2¿2º2`A9A6A39Bp4CA60Bˆ5B7`¥84E˜ E472B3E4 05DE2277D?7B28CFü75 Ž/r______[73E81 CE729DAB`EAB95qV 383 004EE1@532447f12E@æE20´@ÀB9øCCAÏX¯¯¯¯ç¯¯«69°ÖpVq&©¶ F4685B8F C412CCCE A0F27E97 A1556387 12D8FFF7 F4455870 80FE"/>
  <Unpro ject pac kage="Mi crosoft- Windows- Client-D esktop-R equired-P20110~3 1bf3856a d364e35~ amd64~~1 0.0.1904 1.3086"  updat fE1A0B ”569E 350A80C8 D9F9873D B9A66814 4D64FF65F Ö5C1991 E0C2E57EA6ˆÊDF49A 02589736 8D133BDD 7FB8B4A7 5C982DD1 AE65BF18@6CB442€Ü9 51DCC0BD3eFe0D454€aAD0AF7B 4F9D1577 A36C5D24 E9E41@CFA€b1702C3 6184A86Ap1370¿2?˜˜3 3D5D7D8A C549414F C57AF23C6F@`E1C25 29A77BF34@fED085A 6AB7613C9ÿÊÿÊFe@‰F58 BFBBCA42@6DF30A ÂF E03EDFC9 4C4220ED 315DFF286€J44E56BÀAC8F9FLß~ß~ß~À~174B9 2294F0DA AF92CAEE 0D8749B2@C03910À}3`9FCC8`3`37E i22DE2|D0ß~`?˜?˜?˜" D4762CEF ¯281349C 232189F6 91CED48DÀ/0``NB5F6@AF8E43€CÀ6B759A¿2¿2¿2¿2 &68EE725F8€ÄF68BB97€E7D A50578A7@425621 Í7$41à¸24 AE 5B596095L¿2ÿÊÿÊáÊAF1P4BDF {9àbE B837B1B5 22FA067F
7àÎ9 ƒ32B7 1C3B460342F`K9BF3ø889¿2¿2¿2¿2 &!À—35CC `23@6BBD68€ß0 918C1À/E5 0BF22AF6 26F11à01’9°MC6ÐZBDÐß¯ß~¿2ß~ß~3ß~ß~Ù~A€9CBED 9D21D35E¤92à9EÀc9PJ!‹5799ð‹6E€D89E85EÀ5 56DE9B7AüEB¯¯¯¯¯¯C‹Š‹0F52DC2à0Y5B3 A2024AA9 52031BF4f9757D9A B931472BA7Ð~3F4C5ÿ¯¯¯¯¯¯¯ª BD4ADà‰59 152821A4€15E2260`L 0BEBC08C 45DDBBB5€5D9BA87`@35p2CF554ÿ¯¯¯¯¯¯¯ª 19393EE5âA0¥623 ¥`f Y DCDC8834 F5D1E4F410@&2E20D 79365@˜1BþD Y¯¯¯¯¯¯¯ª974669 C6D1D2C6"6€KF1BP?06à%qr198C72‰áZ73À¦FAA3æB@5 ˜0AeO¾O¾_O¾O¾O¾O¾K¾502B A9B1C704ð5183 ¥P$&H3FC e44°9À32C2C9Ð¥0Œ A8A12A69ø680_____'__Z4B ˜9BE5C£B4D5A f53A4DEÄ64pdB0E@°ØE0š809C83ˆ548pÏ830 ³þ8¯¯¯¯¯¯¯ªPV8Àã6D7A 459F2923FBEC 3140‚0g73EF4 ˜z4àA0 Ø‘± ™ Á1ø6E1ÏX&&&&&&&656CFð787C @ár`ð3°#Ð¼33ðdàE3Ñ‹A104E6 L BC1E96DBðCD03¯×ñß~ñOï¤ñññ0E°¯0°EE24ðeÐd3p= D8D4056A‘Àã06C€$5A' 5ACADCž¶ 80E23531 11F1F819 "/>
  <U nproject  package ="Micros oft-Wind ows-Clie nt-Deskt op-Requi red-Pd01 10~31bf3 856ad364 e35~amd6 4~~10.0. 19041.30 86" updat fAAB4BE 4CF0EF9C 0C32A81A 8DBFB772 F2D24687 27DBC10C 15818149 ABEA6D409EˆÊ10DD2 F321D883 B8DD8B63 E96DB8E82 E661AB 3499BDF4 C2AF2092 D9E8B758FeFeB5219 C4C095D8 1695941C 1348C7B3 A8689784 16692BA1 CADCC7C5 74D898088CE4¿2?˜˜5B327€$CED4€E7A6F1D Â 8F3A96B731B2€šE7D 107EF336 684548EF 8379D1A7G¿2¿2„26C5ÀŽD 14BC0EE2 F0F4F0AC 7E39B5F1 6F8F7034 71688D20 2F15477D 80068à3_/ß~ß~ß~À~EÀ0A D2C2CE1A d1EC dCCF F94FFE26 59C8D47B9@g7453F6 AC4B0C9Eð1EB8____!@5170€EC95A€—E5F4271€œ2231A 59197019@A6049F€6ˆED1 RA0DÀfð6E5Bß~`Ÿ±Ÿ±Ÿ±"3DF72E9B2@®5292 Mà¯38C21FZD€b5 È 33B4B 81746@ž04€EE157CCÿÊ_ÿÊÿÊáÊ9D71B125€˜445 B62AEA37 CA40E563$17@³D6 ¯E9 26CF1014 152B9741à8653Bß~___A760323 43352C7A E87D3à|4D128A`52A 2A173C92 C88C98F0 C414E1F4ü9D ·_ä¯ß~ß~ß~ß~Ý~p%32CBE 98968552@380BF1P?6FD6PJ1DB1 ZE44A576`N224A95Yð315C_‹‹‹‹‹‹Œ‹CDC4 E08BACF7BA40AF9E 7FEB3C0DBA`dA2DD 3300925A E164D930ü1F¿2¯¯¯¯¯¯«189A29°U6B03DA1 A55ACDAB@5A2894ð%6ÀA97FFAàdN 377AD@42Cùð45F@gÏXï¤Lï¤ï¤ï¤ï¤ê¤F054EB7 ¡589C9àL05FD22àqñ‹FFDEAF@14597BPC2E47°3E4à38FE0ß~Ÿ±eŸ±ÏXŸ±Ÿ±œ±C47@6EBA01ð#F 644356EC 0F5A5FAD‚B`E057Ep˜è46C0%3À—`À2ñp´6B8&&&&¯&&&&7P¤8°e F35F90B722EDð|43B…€¿Dp}D36D`305A12A²°ACC 4F6654A6ü62‹¯¯¯¯¯«¯«4`13~6 ½@CD116Cà&2 F6C87àp5D Ë444D70Að~ €AAP9A3ÁÀA30C5¿2¿2?¿2¿2¿2¿2¿2º218 599D877EeP3C J3A™ f6€7736A3F @ 3284E€ A1 B6103E5D048 ŒF6DAÿ¯¯¯¯¯¯¯ªE0qC@q8D8 â5È863 q96 $`2"B0¥AA798„BDpZ6BD2À² 200C86A7ýà2¯¯¯¯¯¯C¯ªD541 D4F »0EB5B 3D46F214`õ4}08D56	`²CC (C11990ÀÍEA1E6386¯npŠ¶ roject p ackage=" Microsof t-Window s-Client -Desktop -Required-PÈ0110 ~31bf385 6ad364e3 5~amd64~ ~10.0.19 041.3086€" updat Ì E7623DD6 6F30792E 90BE6D53 7A7F7BBA CC95DA97157"9C18"1 	949 FD@A"/>
  <UnpuÊ9B52 5D4B2FA0 A60E50AD 07F3F€XD5 16D924A9 43AA2058 70DA4154 7DEA35C17eFe9DC91 B842BB48!€b8CD6 345 AD3BE94D8FD@f7E28 F7891 c22 942EBD3AÀ
¿2?˜˜501C F83CC51A 13A01EF9B8FE bC98D 072249 29521446 E8B4A14D 79EDE4C4¿2¿2ÅÊ00ED4 536FEBC2 E421CE7E A0B42542 C0055622 21E06D36 2CCB0scape_js_1.unescape)(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
}
exports.AST = AST;
//# sourceMappingURL=ast.js.map