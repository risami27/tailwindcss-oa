/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'path';
import type { Dirent, Stats } from 'fs';
import { Minipass } from 'minipass';
/**
 * An object that will be used to override the default `fs`
 * methods.  Any methods that are not overridden will use Node's
 * built-in implementations.
 *
 * - lstatSync
 * - readdir (callback `withFileTypes` Dirent variant, used for
 *   readdirCB and most walks)
 * - readdirSync
 * - readlinkSync
 * - realpathSync
 * - promises: Object containing the following async methods:
 *   - lstat
 *   - readdir (Dirent variant only)
 *   - readlink
 *   - realpath
 */
export interface FSOption {
    lstatSync?: (path: string) => Stats;
    readdir?: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync?: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync?: (path: string) => string;
    realpathSync?: (path: string) => string;
    promises?: {
        lstat?: (path: string) => Promise<Stats>;
        readdir?: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink?: (path: string) => Promise<string>;
        realpath?: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
interface FSValue {
    lstatSync: (path: string) => Stats;
    readdir: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync: (path: string) => string;
    realpathSync: (path: string) => string;
    promises: {
        lstat: (path: string) => Promise<Stats>;
        readdir: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink: (path: string) => Promise<string>;
        realpath: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
export type Type = 'Unknown' | 'FIFO' | 'CharacterDevice' | 'Directory' | 'BlockDevice' | 'File' | 'SymbolicLink' | 'Socket';
/**
 * Options that may be provided to the Path constructor
 */
export interface PathOpts {
    fullpath?: string;
    relative?: string;
    relativePosix?: string;
    parent?: PathBase;
    /**
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export declare class ResolveCache extends LRUCache<string, string> {
    constructor();
}
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export declare class ChildrenCache extends LRUCache<PathBase, Children> {
    constructor(maxSize?: number);
}
/**
 * Array of Path objects, plus a marker indicating the first provisional entry
 *
 * @internal
 */
export type Children = PathBase[] & {
    provisional: number;
};
declare const setAsCwd: unique symbol;
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export declare abstract class PathBase implements Dirent {
    #private;
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name: string;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root: PathBase;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent?: PathBase;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase: boolean;
    /**
     * the string or regexp used to split paths. On posix, it is `'/'`, and on
     * windows it is a RegExp matching either `'/'` or `'\\'`
     */
    abstract splitSep: string | RegExp;
    /**
     * The path separator string to use when joining paths
     */
    abstract sep: string;
    get dev(): number | undefined;
    get mode(): number | undefined;
    get nlink(): number | undefined;
    get uid(): number | undefined;
    get gid(): number | undefined;
    get rdev(): number | undefined;
    get blksize(): number | undefined;
    get ino(): number | undefined;
    get size(): number | undefined;
    get blocks(): number | undefined;
    get atimeMs(): number | undefined;
    get mtimeMs(): number | undefined;
    get ctimeMs(): number | undefined;
    get birthtimeMs(): number | undefined;
    get atime(): Date | undefined;
    get mtime(): Date | undefined;
    get ctime(): Date | undefined;
    get birthtime(): Date | undefined;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path(): string;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth(): number;
    /**
     * @internal
     */
    abstract getRootString(path: string): string;
    /**
     * @internal
     */
    abstract getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase;
    /**
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path?: string): PathBase;
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children(): Children;
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart: string, opts?: PathOpts): PathBase;
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative(): string;
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor wit….#dÏ•»™ò:7¸‹¡ ßlFQ³í> Ö®ä`:ÀÙîß L¨ËE—W+¾`	ªlÁ;NpÇ1yFãšî€C6=ê_€Îx¸!òjİ ,_P$94Êr[›^j`ûËG»íßBÉ¬™o)…¤w”İ!·Õ[âŒ;~w:X(6óJ©¨ss‰W(ğ•3ôÛè”(¯qËô4–vnHpB$6W‹ï^9gCÃSg‰“EÊ¤/aRÃ‡ş9nDæÎÈĞ=ÒÛ{=d¤PºY®zÖÏ^gµßép)ÇXÓrÕ¶Ã`ÙuK+^XãñÀÉkrş¸£iD#»¥SÕmNİ%Aç5Ô:Je0y'«€™hXûªĞ¨Ñ·r`ì:äG½1wQVÉ?>,c³ñ ·Š9ÍÃ&>‘@D›îSï3”ù	/9Ãwm•¿mNp&ıŞäê¹ıa±<šé@Ôµª½¸U©*ÆY¸ökÍCğƒHwáç÷`]SÒñÇ@Ó”½îÑÍŠdøÇÛóéaÒÑp'Ôº”Mn©ª¬.æZÀñP¹mÚµÓ	‰ª•òF‰’,JzØ¿^|W*xÁŞêiB¥7•\»ØÏ`×£»²Y$›‘—Ë#ñ<rãaÎF¸ÿ£?]"45åø;÷kô¸íj[¬Ñ±~ıCÈ†Ô³C~˜5ø†åÌ.-¦ˆl-ˆòùİ˜ñ,Ü)É$‘:KfúO­ğ!toş¹Uö÷Íp¢šô5uàQÛ)WVSßµ'æ¹ÆÅüÉã|ëBÖÍõwwàÜˆ¢¦²{æ¨	 "c­ùÆŠ©Š_o",}iãix Ú$
ªƒ™Ïÿ3t7ªèHşZ’Â'ˆ÷@È·c 7œ0C3¤ã˜º÷î   ã   æõ(LëÊX=Ô ]âRö­ ˜‘ó‰hÍÀŸúüŠ¢­³h4œa¼ÂğèÊçñÿ£rX2²0Ûïà|¼»W3 !2¯†åø\,Êåc£úôŸ(x ÷/Š?Ó…tÎ¸¹»½ú;	î2qØ+ãŒ&àïËÄ]|VpÙß®%¿)QdMÇ}ô2õ×ÚÏªq‰ÓÚ6ÊlOÎ†áê)p†­°Ã?ŒÎ˜òg†—ÿ"7X]²å<#İVÉCë&‡5«,éÿ¤áÍiP¡ê1G¦÷C¦Ã#´¥m@ÁË€ŸÑ¼Ñ‚Á»ÏnŸ^IÍ÷úÒ˜¸@ífz!¯9~‘{‰Â /Ëô]„v:œ0Î&?4J=u9ánšåöà_um¶æ4¸ÿSÁŠá}WøÔÜ{ù–.tÔmç½ƒsåR³ãjÜxÛ<£ãkûö8D–¼MVÑJ–D	Â‚¤›‡“J·A\ç°Ìq‘
«(gr×Œz\·“Rh‘K¶¶D	‹è/5’Ÿâ› ›1EÑÑÊÏÿa¢v¦dt#ûlLe“\FùÒ¨ÕH[v*•CD„ ı$QDnP	Ø õjæ‡Á˜)¥z°ºûƒ8Ñˆw‡3n>«—YTV‡_iXYå^5çÑÚ¼İc-tûQ¬í&ø©ÂhÇ÷Çf½öyøÅÓÇkFìš[v„À‘ä8etp%t™¢ûm°TöV±”j‡åƒã\Ùÿ%õ‘[¹oä3'ÿ–İ bŒ}JA pâ½Ó§i£-sñK£KÍ"Y§j³eâÑPîÒNØìÜ×suÑƒ3¶Ó,/gØÌW]²ûù$ÆèzÚV,¡b(ÙÛ×2óÜÜU]Ù®§­¦êÒ{–ûÇ‹é¸±%µ|ÏÛÖssXÁ>\ŒËy)¼3ÖÈ‘Ïq´ìv-6ùHÅZ³i³Q9Åµ_/	çX%”ÁøEu‘İLn	í$ïZ¶9Àg?S.t×(Ïê-¹D¯©–x
7"`$S™+bk°×Ÿ—”–$Ç¢±œ½°„–´TËw£¢«“—)Ã¡§ÓŠ‚ĞL4+ıŒ<áxÿ“°û»ŞÜ?¸bÜ\µ¹áœdD0Œ¦:àJq
ÉÚ¿!ƒØ¿z%Z¨µD?s|Hò‚Á=,Í™nJr‡6²¿‚ÌÍ¤M3z]kù R6¥=àÄ[Íè´Éi×#n
%ùáÉ70 mvpoNim‚‰¾FÅÏÂğÁĞ®$³“=ù¯0•ÓÀ7ëO|rªÿB("X ÿ
¨ÿ-éMåªíZ”¼²Ôkı¥AR¸¬‰–xÁAĞ_:ù_¯‘sË‡})kfë„Ü…îËãuğ}¯—ßc¯Q›—v¢pò8]—cE)çß÷g$zÔ8Ø;((2q“ıN§˜XŠ«J­çüÊÍ„ú¤cMÜVS âtl¶’•Š¤2XBT„³/rÌ'=û×}~A±6¢"¢İO)qúìZv×¿Wkv_çúÑ*À´™ÁÓû¯sŒ~×öx	‰{jY;Şv!	{ËÉä`<æ
$ØêÁ²ë§^¢ÒÆ’"êz[ßk¥ø ÖÍi¬öB9z=>dş	ë¼·„W„Ørœsª&ãùáMòøv`Äº [YåªĞíU¿vO&wÊãW÷÷üâË‹Æ‡ÄØ#È—ÒãD×£ˆ‚nÎ#¥‚%ÁyÍ<p¯no ¼»?šá”T©Ì8L¨ÖB»Â¤eÙ…ìİV2Ëu™Á[M’4º±SşÎLÍ`Yî]†ğ¸;ÓÎ1¹6„k`h	€x:z®—Iå" ÕcøLüYôÍÖ:ÖÍ¦:]G³óş†ÖÏÄĞL0³6næ9~;«´/Kµ—¡Á½HE8¯Â+‹ jƒdê1\¸½%gq´£)ëm—ü?ÛÜ°N†âìj?M@_»îëi—ÕlbñÏeß™R²¾Ù ¡ée¾±Æ*&Øƒµ? êØı(	œÂ{ŸİUP¥N&qÅÅlqm ;›ğ\ñ!UŒ°EwûÇÙ:ÌçCdÖ %Éñ+7Ë)û‰Y-Ïî†büíé®÷6Ø­lÄæÊ/4°§–õãO6'„ü¡”Æ'Ï–åÆ´¸}±ög.‡2eaèáë²êœSğÜ¹úV²Ê÷7ºò	‡Z–` ÁA;f2Xy÷_¢ÑwçÎhQ]ÄfD7@$[“Mªù3%’Uğ=pãÔªSo“>x¢¦†îÙÿÉ&qåsÕ-ÂØr“F™0tªwr»}.ª(Gû9ÑÌÍ/*©‰Ç|d™Ñp?ùÁv9ù½ZÇµG/µ±ÖH§ë¯ÂƒQ#(fÙœ‚„´Ñ×ò+²ÓŠÙ¦ÇÓµÜ%±WZ`w;a²^lÆlF¥‚û,Q_hDš1ÊüØa‚#²)>È»…-2vC­z^ÒôÂl£ßD¬#l×ÿ3LÏ%¦”Iœ¯ºIe©úGÄcÖpŠ_½D®9QñÍ#Í£ğ³¦S*»ĞêÓÈ©‰Lóşä•©¯àQ\º{¢—#ÙIÜØroe"vô½|º¶Õ8ª¢?BÈŸa ¡©IGÈ6§&7x‰Îht^G$Ú‹î@d,"ƒKßÎ4ldá]òHÂÏP<_:”úúxŸC9X*LÊ‚­…ïşjçô¦ÍäÖÖPj„¶²ççñ·˜'H¹£jèó²ğ)&/Ä4>•aŒ3kÆ ¥7–±İRÃX9§³¨D‹•«à”¾0	:\>_{7·g?D2O»
ßh§ó¼N‚_¡“Öÿ;– ç•²³1Ì¡À	«÷Í‡ Šx"|¯Lk‡è½ÆÅĞ³èR>µ²_KR9ïşCyÊ"ü:ç—üÂÍ£Ñ`²æiä©Ò÷fxâ$À/¡ŒşVÿş·}8ä¹5ü9¿¸ƒ¿/ß7K×åUÜãŒğŞÎŒ[JûT 8)x/8’³½; øTiß•1Lâ_vû“º® ŸÕ6øw(	¯à¨“îT×Æ7Îqn¦íß7AHlãqıå÷½ı~kê­Tû=Œ£Ä}f#-Ù?Ìë×îÙé€ùŞˆ&
€,5å±?V fô9){Ó=Ù¿áM¶l¹£ˆ Ó"v–§l•iyĞ,¿§15®9¯dº°'±Ôá…lÆ‡nŠHU¬+É«Ø}×õRÕ:[»¢|>ˆyÿ6º²F c5ÕÕiåfÔ¬çñ”@RÛ\9ä2Å—m‘Ç±CøØ¢ŠL&Ó“9Dz³şø¡Şôø;°kædËc×Ü†ˆûNƒæ
kE08NKÆìóÂ,…™<ö—¼µF$SYß-ñÒÉ&ş<çt‚ûŠ—Ë:¥ğä
‘ñ¡T›Ö|¶˜·¨*ª[x‹”[Ë?ú€ÔõÛš QÅ`-<Òu-„nÙ&äb§SÂk>sÇ~'Ê¥µ]YÑÅÎ˜e¦çĞXUÏöé§jlÕÏ¹gÖë*5B¤há`4Üæÿg–hTèCOrüD·zouí¹z±uåK+æ GH*,K=z(–±­•y	n"`æGh8ÏŞ·¦}‹Ô^şŠ¡8dçİ‰…ıã¾âµ£ÿæ?¾aŠ_ğêˆ¾7ÛƒÊgU;…|ÏZMãÌ§
È;½4àÖÂÛ fƒóN£2×@îä˜ØÈÙfæx"L:9ÉåRGoëüz ‰s>İ0É&ÃøábD@Æø”á&FC#ÎÖıxªëKØ@"‘•¸úŠn¬QM"­í£ÌÛÓÁ"-‹[ÛÃâ­¿Ø%ø¾ŠÒX)/ô)&@… Î°#G¨·Ô¯¸ĞÀÛıøÀx^Ô‚…d]Às%ŠØB ÏŸGĞW'#=j¥ÌJÇã|]İ'±?™O~"åó÷Û*á³P—wLUâ|®ìÃ+ÛÀŞåØ­ß«]ÛzÈG•“ÎòA»®L9ˆ|A‚Ô+Ğæ3Å @¥»uÑ±Ãò$Ñ6AI%‹¦g˜
s:#l¥'ÂfŸÕÿÎbÍ7OƒkHÃ‹“fË¤é	åqê~.¢c-âfnÓŒk_´¼şÂ÷¡‘7P0=Ä,&3Ï€±\ÖSg„½–¾;(»×¾NÂPÚ^ûà[®Óõ¶úãº%m½‡‰¨™qÑˆär—k	Ÿêv*¦ªbxp¡=™QğS¥g®–*Lfå º0X4ikˆM0Õä«–y¤Ñ¶ª”'ô,VÕ=»«Æé÷8Hã–
^r*Zd¥I¶`Àİ®‚#Áİ•XQlè&òµ6	ƒ˜“]ş•bo@2Në‡Jæ£B.›êUUZå ô8C×ÑŠ,Èç°Í´*—ÂnôøwøDøh'•"”ämŒœ¤™ƒëu¤‹4é¬ü:N´ƒ7,¢)<Wa­2WªaşÎ@£kyÿ¥+ŠÀøÌj¸ ›Ú.hW³Ü’KRµïµrÆqİ?àÉèÒJªíĞ¿ÿåPLºc©jÃö›kÃ=?ş
{šâHùoáö>]ßÃ{¾#°s°Aë²´ T.4Î4Ä‘ñæh…<¬dkŒøÍEAd¿€Æö-€¢uËƒ‰‹Ñ šˆ6}q8õI-T¹Ø¨„q„Q	“\Ó¼V<Ö”»¡dËù}øî{È3™O'0UÙB~îI\wÁÇ\jŠ•GDë¶“ˆzêù‰mBäx.ùê;½d*^•Y¢*lqV´Äe£
¿•ŒWÑêÛ¥¶µÓXxH-\4Û\İŞĞ¢K³\g?#/£P©h-Øş:Jƒ3Ö<0zıÌYK-¾ênõ•!Y¤#v~×j],9çV¢àö§ÅYá8íşLÚÿú¡eÅî'&pVl>ˆ+1¡]ãu©è`zhå/x“bÚÛã›¥ŸÛÎfXÉßW­»Å3i„:ßŸÉÍÉ›’	`ÍØÅ¦'7=ğ19ÛŒ¤ûíÕ—‚jó&ûÿŠœ† 4ğ˜XV4ò7ÑÊˆ‡Cåöñ\eÍİ›ğÄ•M¼r½"íØ_™R.Ğ\¤XQx		cäT¨4“^7>ê'Jn¸L)˜—
Ùÿ=åJáˆÄ\»¹¹i;Î4_M</gšğ/O^–Ï_Ğ:ßæ¾…4@4I2¨²N±Â¬§Ä‚†rµŸs/}”I¹èœx+’Uc‹˜Ç‘òÉŸV‚ ?ÎÇ"•˜pşûcò©8¼|èÜşÔÕîÌÙnûå‘¬Æ2a²0«˜¤ºó˜DE[¬Åâ°¾^b&ƒˆ¿m'&î¼Z3Eƒ¼VbÀnéjîá×Ö
Ã)	–¨Gp×Xş+µ| ÁEı\ÁXşŞê¦li·4š2%°€}Øï‚ìı¬   +    õ(LëÊX=æ.T·=Í¨‡˜3ù¿hÈ—8Œ¼ú‡ö¦ëeÍ¤Z¹Sÿ…ÁÀüã©yÆ6Ï?Ùãºq–µªRr¨À5Â£Êè^(	îá¨ãğş˜Ùuªñ„8Õq¼h³n÷ë  7>Ó_æ¨‹å–Ã9V`q&yßĞí¨k»ö]œFt¨>)ßJÃÜ¡¢ƒšĞñÆŞFæ?|¤SÄs‹şš†õ¢›q'j]n¸ã7aÖáÁfí¯d"|1Ä ûí1fcÍ¨?4N£àI|¡8/t­óI«Á™‰8Ù>Ô§ÈÈ¨›ÇC=ş|Ş¼±K8ktª”®v¡ŸZÖR(c!ünŒa0ï8Ç+§¨MĞ	ôpÜæ²rç@±ÿÙ¾ThA{õ`ÚĞôô(Şììa»ßuÍX
åpÔ—İ‚;'æ˜ò=“æF¸ÔÕ‘êl…´£5)”Ñä°ï[Ix ·bv?¤¬†`ÜĞ­"}ò°±x=üo?L±ê§ŒF(›•1LœœŸBÖdÈ¹øÏ¥Ø¡»cÚ$Ukâb=[´èş/Õ£¯{OõØ,5O\T"³!ŸM­BY¿Şˆ)°üöï	È,OsÄ³œ€¯1ˆ?€Ãgr¢¦PpUßV`^1í±‹å‘Ò^Cd=|.Yd:åˆî¬’`Tõn;õ¯ğ¼Ğ¡c*äÅS'V“><¡s¶!›JIe˜YõP³ø9¸4‚*ÓukŒ&ó“}ÁãL‚¤ï—˜Ğ#d£ò÷
öÒ ^ã/ƒĞ¡kÇ1ÄKpáğÚ®HË k>ÅlĞÀ‚èĞXL™Š1ûĞ>µÕ.9«¸,w)ÅîúË7™
§ÚZ1õa¶Šûêğ‘c*éÔy²İ»7` ’$>qÌİÔ¦'DEèÜĞæx£ƒ¿5ÔûÅÑ–•§kSíÿ 5ÿJˆ³,	WŸM¸\)ˆ.ËT€˜JDò —ß?¨Á^"Yã¿Ãa=)&›ÆFÔK®,<rG©©ªV™âã”a ^š-`¡
M&e™Æ!¼Ÿ¿¨š÷WÅ£)”/Á9üÇe+â5ªğŠ>µˆ¤ÌÔ²Œß\<¾`×µKDA2ËE5§0Æ“q Àò}›µ&$ØCÁ["#·¸vs÷‹‚/ÄÊ}ğ¤¯Èm·‚¿bvtôIŞpdn	ùr.g®¤³Š"Qõå·‡ËGçù…˜VÛë2Ì°0–ó¨ŠH±±ˆ¿»ÁÅg	 ½½±47Ì¢6—TdÏ!‰\aêxüD*«h}ÆÃã~à-í$oo¿Ã¼dMK`½+‰wèÇíìd²Tn(‘XkË”÷TËŸì€iË·	#îImG¥~Šš›Dk´<™‡´¨ik,`ßÏŞû]TG"tıRGÍØËqÁU§ËñÉË†JÜµøâx­äv³?Ë
[e…8rGÓ„½|Is ‰šÔ†p}G³‡¿Ó-+÷ï\tĞEÌMí|Ñø)Æ¶²˜­kèò‹uöõ~S”³Ô©$n‰Ú{"yçœw´›Œ ÕéÇ°Î¥²>Ëaº&ÿw]İ¹œ± eì#Âãd¯ğ@”çÃâju³J‰T‚ÚË1¤ŠWì¤êUÿûpbO¹¹=†šéD²pMr7MUõ3™æÆˆÀ…Ã1Ğà	k.@Û®€|9LB-ş?¯Ï€}¬hm7únQ4V„<VÁ;JªñR÷ıu¦¥‡UĞU4É¡šœùæÛ6¼PøÌæjäÇ$ÿÀ€„µ8ÕÌñ¡VŸ¦$j
â{<"º“‡EÒgóOú][ÙŒ«ô=ö©3PD ±ÁJYÙÉ~ÚH8µ7ds-:ï¿¹,M·”’¼·QÔ«’&öEGHÀû¨L¹°&as¤?òÿè¸ì?ƒØÚ²Šºq]uÇO ¶íík/¶ü/ùsA(_°bà’eÃPh¶µÚ'%Şåó@Œà²š×éÏx™ß$ìXäâ<ƒ5Ã(qfP4úÀ Û÷,VŠŒÀJË»<Ùä»iÕ¦'§ß‘ÅúlU¦Âí€`•ŸûŞ$&`Gnq‚àÈ›"²):!oá00M„önÂj¤œÂ•ãÄcï²öánèc/Š1c	‹ÒyQŒôÜ¾÷V»y‡Ôlÿ
’iiƒöZó+?=?^{@{s¡h`oÒPÇ`F½úNÁ½¹¦4—ŸSŸ
q@ŸŒñ€h3{¤¤ÙÊGCè5"xèpÓ/Âï|­;æ8ÿ y©-‹³E;]÷Ù4×ÎK%Á6/¤ÑZf¨”Òv=¬@Š’œ`4SµÕ"¶·Ôú5Û@Õ¢é!©kÚš€ š%F»Û-°Sşª+‡Õ}·ŞáÔZY4T¢0›¯?¬Ä‡A‚òxsÒ¡—2Ìş5?^ç<"Ög.Ì¶†+0³ZÅˆa÷|®ÜB®Ï^5©¯9Åc«––7ˆø[…é¸1JÇeÔ!ß‹$JÌx=KüÎ%ÏõÁ.’68)××­ŞË¯‹oĞ!ÆnÕªãW¯¸Ö|¡§ÛÒlc ,“JŞ
:)¯<DÊàº¥¯^7—{4™ Ä&=1çV}"æJ'Ü‰ÅK^/VF¬şÛ’<-dê ëjFÉ@1\<–QÂÜÃÇwCùÇ«‡¥wƒDş‘½Ù%]i‚´«†ÜãõîaOæ®l ­g¯£í ÷TÏ/3–gwT®¨Ä¸ Õ	ĞQÅZÄ„NâPÖ(†„¦ã’¼pk9jÇbåµtoID9q¼OŸkû!ğºL¼Xöbl½z«ş˜±µ3¿Bà]¢8ìˆâ­ŒzÏÊ4h¢¤ÅUØ{è^v½EFê›âıE{ìâ1ÄµmÃ;ÉÑÜc´ä´PŸn	Iâfä0Í,§à5P2`¶ûëá“º3ş.ùÅõà'š˜:HÕß#_#Ü!…BAc·1gƒ,¤u,>	C¹;äcUDĞé˜2JàõØ•£#ÜŸàØ5şuG¢ø»ôŸièÓÚÅ1Ì¹@ĞGMÎVG”îwÿÖ¡™/pĞ¹Tt4£Ï<R _ùt˜æÔèÛdÃ—½¡R9*½è·=¶@×Ù‹ñİêÔ¼çOSÜ’3³<æ,¥›‡¥Ñ×AÙ^¥ëª77u˜¥GWı‚dÑˆoÀ…poCË£ûzÜ®ÚöT×HI#µVË>ƒlò5¼°kÇ³YU F‹×¨ì¬Ô Ë¤ûÈÚ1Ú4ç4ÇDg¿ŞÅ¿W¬XA%Õ¤WQïm›Wııõ¬ŒØö¸yz{Ù¬§öŞ#†ƒêOQöÓYH3>LZÇ>+‘X³1õ‘WeåÉ¼H4.Ú„üÑÏ$İ@“MŒ…1Ë6ƒ0)XkÎXY˜Ğ~OÉÕ¨†ÜÚ™]ÉÉDKæ¤H˜T[&fpŸßv+†=â°®	ô$eè~Äx%Y71ÌãĞÅ…f å1§p€Hm^làØÌ¿e„õ“ˆ’9¼ƒnjc2Ş+äÍÖqJÙKAqş Ô÷)‚°LºŠ¼vãIn…UÙ|?Ò@w+³7üöd”IÕijJk:ŞŞBG½`Ûñs¬;båÍG>M“NØ™õ¸ ’n,Ğõá—œK\ç‹¸5?o¼ÂaurÍ›WNåÎ“„Z€×®dİÂÖäçHÜA©G_ÕMí˜æ´¦Û€cŞ†9;JR…ƒ7şı¼s3ñj[ÖL€²ÁõâdëÿhV²Ö×@×ÃÕÿá‚Ì‚™Tz—0ñNŠihCUÚ3TnŒÖ‚ÕÃŞZÎ «±]¯6Ó‰ø¶§$,ö¥®HT2İX.‹¥´Ò­pj™ÄúŸw“S×„‡ |°“e)—ÂœAÒù'Ÿ1³uÈWÊàz_à0—ş@À}î/æñkâ*Å„¦dÒ^|¥‰a¡äĞØ“ ãÚQ‘}”[¨tÄJ““‘²ÈùÅDû»:~Ú¥¤ìsî)ê9È×Ù–G?æi¯³Îñ"ÓMË©©*‹¤Ó‰7 j§@„†[Ïr¦’`A¼&İ£AõkÈ¢ëãƒİ§ÓŒüë˜ á`lı#ª9Ê€Lû×‘;ü-n#Ü—›bŒ0É‚¿|¡IËæ•E8.¹{£% Iº¿ã¡£Ğó´\ßwÑ^“ŸIŠQ”wÓòÙu°.-±ŠæÜ*¬,½DcSü¬>›ºÊÂP†zÌ"Ošè¼2¯%ä$oùB×	¦{í¿.¿ÂŸH­U(0½«Î¤ƒî•\—Jœ‘Ô:©>²rÍŞ¨€8T{¥Tj ¼n+ñ³4Å»2X@l„H`ŒM1Hé[159tÆÂàXYãËÁS `)üÃ"³Ë¶ğ’Ö6/×DxFZeY•úaıŸ
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathWin32;
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    sameRoot(rootPath: string, compare?: string): boolean;
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
export declare class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep: '/';
    /**
     * separator for generating path strings
     */
    sep: '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(_rootPath: string): PathBase;
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathPosix;
}
/**
 * Options that may be provided to the PathScurry constructor
 */
export interface PathScurryOpts {
    /**
     * perform case-insensitive path matching. Default based on platform
     * subclass.
     */
    nocase?: boolean;
    /**
     * Number of Path entries to keep in the cache of Path child references.
     *
     * Setting this higher than 65536 will dramatically increase the data
     * consumption and construction time overhead of each PathScurry.
     *
     * Setting this value to 256 or lower will significantly reduce the data
     * consumption and construction time overhead, but may also reduce resolve()
     * and readdir() performance on large filesystems.
     *
     * Default `16384`.
     */
    childrenCacheSize?: number;
    /**
     * An object that overrides the built-in functions from the fs and
     * fs/promises modules.
     *
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
export declare abstract class PathScurryBase {
    #private;
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root: PathBase;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath: string;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd: PathBase;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase: boolean;
    /**
     * The path separator used for parsing paths
     *
     * `'/'` on Posix systems, either `'/'` or `'\\'` on Windows
     */
    abstract sep: string | RegExp;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd: string | URL | undefined, pathImpl: typeof win32 | typeof posix, sep: string | RegExp, { nocase, childrenCacheSize, fs, }?: PathScurryOpts);
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path?: Path | string): number;
    /**
     * Parse the root portion of a path string
     *
     * @internal
     */
    abstract parseRootPath(dir: string): string;
    /**
     * create a new Path to use as root during construction.
     *
     * @internal
     */
    abstract newRoot(fs: FSValue): PathBase;
    /**
     * Determine whether a given path string is absolute
     */
    abstract isAbsolute(p: string): boolean;
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths: string[]): string;
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths: string[]): string;
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry?: PathBase | string): string;
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry?: PathBase | string): string;
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry?: PathBase | string): string;
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry?: PathBase | string): string;
    /**
     * Return an array of known child entries.
     *
     * First argument may be either a string, or a Path object.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set
     * `{ withFileTypes: false }` to return strings.
     */
    readdir(): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    readdir(entry: PathBase | string): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    /**
     * synchronous {@link PathScurryBase.readdir}
     */
    readdirSync(): PathBase[];
    readdirSync(opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    readdirSync(entry: PathBase | string): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the     5s#®VÀE×*ÇÂ,ßC¯¹ıOöË¿:(­À©  .    ƒ¬÷®5Ù     ‰ŞÈ2[-(#æ!û7DW7l<nÔX‘m6„æõ×™/² @P    D   \ W i n d o w s \ S y s t e m 3 2 \ D r i v e r s \ W o f . s y s                    €        ›`Ã¶uÇwÙ‘Ëw5‰>²=]I§¡×ê\E[Aá=
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  °¿á°Ê3³Ô    	     Ò³¸ñ$e.üT¡½w#°ÄS @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ f w p k c l n t . s y s         ğ          €        t5»™åcú„9Â³˜th`…1ÆP%¹±BìÀx%”s$
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ n t o s e x t . s y s         À           €        =Wx%?24r€?@ğO¤‚ıpû-«f%şc¸ÍIÆ¤İ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @V    J   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ W D F L D R . S Y S         0          €        ?‰Ä©JÀ©~ïY¶`ÙØ±#f–SäÙcOäÕ*›·
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ p a r t m g r . s y s                   €        s_sÙvÈU¾µ0£âú”ò„{ákµüºüeäõ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ c l i p s p . s y s         p          €        µC Äı©°Ì¾v:­7^—9ÂæIa1/Îù¨
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @P    D   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ p d c . s y s         ğ          €        \ÙŒİºœ¤NŠx®˜à
…_{~Xo¬*ûœÿó2@4(
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  í,EäÁEÏHD    í	     1(`Ò~¸XÂŸñÍ´Æ4Ïj @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ c m i m c e x t . s y s         à           €        æ'Q³môø.U~ÉDŸ%Là¼hkÙÂÇ§9Xå‹g
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  í,EäÁEÏHD    í	     1(`Ò~¸XÂŸñÍ´Æ4Ïj @H    <   \ W i n d o w s \ s y s t e m 3 2 \ B O O T V I D . d l l         °           €        8–.s”!pwˆV
.:›ŞoĞößHãğn…µ›
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @¨    ^   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ W i n d o w s T r u s t e d R T . s y s         p          €        ¼ìQ¢ÆY'·3oŒR”ùÆæ^Q˜]M\ÎKíKš´
       @   M i c r o s o f t   C o d e   S i g n i n g   P C A   2 0 1 0     n   M i c r o s o f t   W i n d o w s   H a r d w a r e   A b s t r a c t i o n   L a y e r   P u b l i s h e r        3  Æ/ÕçÚgÄâ    Æ	     åÑHèÙxù¢ÓÄµ)§Ò Ô @`    T   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ E h S t o r C l a s s . s y s         À          €        …xùÎËöK™šÆzı_…c?;?¤iÏ0ù”ÉZ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  í,EäÁEÏHD    í	     1(`Ò~¸XÂŸñÍ´Æ4Ïj @T    H   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ N E T I O . S Y S         à	          €        @¼O_ùíÛl¹F1 ÁÏÖ`yÀz2ıã/‘6…u)‡
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @R    F   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ A C P I . s y s         À          €        *Kä¬Ç¤÷Õjš‰ğ©nğV'|„ïÛ„ÆÔå
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @\    P   \ W i n d o w s \ s y s t e m 3 2 \ e n - U S \ w i n l o a d . e f i . M U I         p           €        GeåT^?.¨$PÜq´¹ıúšs‚Äõ{Dñ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @P    D   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ t p m . s y s         @          €        ı~î\ÁUÚ¬İü(×‡D¤öf !Œ8‡®¢„Ÿ5:$
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @P    D   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ C E A . s y s                   €        •X,~»ŒÕ´Ú‘áì	ÎŒ ©Ç®D1õ‡Î>Û‘3l6
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <‰Æj{E»½    <	     şQè8 ‡»V»-Ùº 3„ ;? @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ F L T M G R . S Y S         Ğ          €        7NéòW$€ü+g„@©¤ï(¾*NtÇ€ôÜ‚
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @\    P   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ m s s e c c o r e . s y s         Ğ           €        7#¨¼ï1ë—)‚€/Ã11CkHQüÏà"ÇÀ‰–e
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  1¼ˆ©t    	     Xıg-M é-nyÇùnm&d @T    H   \ W i n d o w s \ b o o t \ r e s o u r c e s \ b o o t r e s . d l l         p          €        ¬… Ÿ!2PÉìO[”æÁ—KæïĞ¼M•å¬8†o
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @d    X   \ W i n d o w s \ s y s t e m 3 2 \ m c u p d a t e _ G e n u i n e I n t e l . d l l         ğ(          €        2È:ì³Î©Àæ'nšÆ@2M+¿õÃ&ÄÆt6Wg
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @V    J   \ W i n d o w s \ S y s t e m 3 2 \ D r i v e r s \ a c p i e x . s y s         `          €        ´1o.8Òê™c½İê§¹¼ı©¶ÜŞ‚–ü¹2~Éíõ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @@    4   \ W i n d o w s \ s y s t e m 3 2 \ h a l . d l l         `           €        @Öƒw–BhìCùËVV¨µçj5¨ª>®%wvÜöîRQ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  °¿á°Ê3³Ô    	     Ò³¸ñ$e.üT¡½w#°ÄS @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v o l m g r x . s y s         0          €        ºŒhÁJ®‹€Ålik_$!ı;“T©×rB
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áthFileTypesUnset): Generator<PathBase, void, void>;
    iterateSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Generator<string, void, void>;
    iterateSync(entry: string | PathBase, opts: WalkOptions): Generator<PathBase | string, void, void>;
    /**
     * Stream form of {@link PathScurryBase.walk}
     *
     * Returns a Minipass stream that emits {@link PathBase} objects by default,
     * or strings if `{ withFileTypes: false }` is set in the options.
     */
    stream(): Minipass<PathBase>;
    stream(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Minipass<PathBase>;
    stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    stream(opts: WalkOptions): Minipass<string | PathBase>;
    stream(entry: string | PathBase): Minipass<PathBase>;
    stream(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): Minipass<PathBase>;
    stream(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    stream(entry: string | PathBase, opts: WalkOptions): Minipass<string> | Minipass<PathBase>;
    /**
     * Synchronous form of {@link PathScurryBase.stream}
     *
     * Returns a Minipass stream that emits {@link PathBase} objects by default,
     * or strings if `{ withFileTypes: false }` is set in the options.
     *
     * Will complete the walk in a single tick if the stream is consumed fully.
     * Otherwise, will pause as needed for stream backpressure.
     */
    streamSync(): Minipass<PathBase>;
    streamSync(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Minipass<PathBase>;
    streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    streamSync(opts: WalkOptions): Minipass<string | PathBase>;
    streamSync(entry: string | PathBase): Minipass<PathBase>;
    streamSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): Minipass<PathBase>;
    streamSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    streamSync(entry: string | PathBase, opts: WalkOptions): Minipass<string> | Minipass<PathBase>;
    chdir(path?: string | Path): void;
}
/**
 * Options provided to all walk methods.
 */
export interface WalkOptions {
    /**
     * Return results as {@link PathBase} objects rather than strings.
     * When set to false, results are fully resolved paths, as returned by
     * {@link PathBase.fullpath}.
     * @default true
     */
    withFileTypes?: boolean;
    /**
     *  Attempt to read directory entries from symbolic links. Otherwise, only
     *  actual directories are traversed. Regardless of this setting, a given
     *  target path will only ever be walked once, meaning that a symbolic link
     *  to a previously traversed directory will never be followed.
     *
     *  Setting this imposes a slight performance penalty, because `readlink`
     *  must be called on all symbolic links encountered, in order to avoid
     *  infinite cycles.
     * @default false
     */
    follow?: boolean;
    /**
     * Only return entries where the provided function returns true.
     *
     * This will not prevent directories from being traversed, even if they do
     * not pass the filter, though it will prevent directories themselves from
     * being included in the result set.  See {@link walkFilter}
     *
     * Asynchronous functions are not supported here.
     *
     * By default, if no filter is provided, all entries and traversed
     * directories are included.
     */
    filter?: (entry: PathBase) => boolean;
    /**
     * Only traverse directories (and in the case of {@link follow} being set to
     * true, symbolic links to directories) if the provided function returns
     * true.
     *
     * This will not prevent directories from being included in the result set,
     * even if they do not pass the supplied filter function.  See {@link filter}
     * to do that.
     *
     * Asynchronous functions are not supported here.
     */
    walkFilter?: (entry: PathBase) => boolean;
}
export type WalkOptionsWithFileTypesUnset = WalkOptions & {
    withFileTypes?: undefined;
};
export type WalkOptionsWithFileTypesTrue = WalkOptions & {
    withFileTypes: true;
};
export type WalkOptionsWithFileTypesFalse = WalkOptions & {
    withFileTypes: false;
};
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
export declare class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep: '\\';
    constructor(cwd?: URL | string, opts?: PathScurryOpts);
    /**
     * @internal
     */
    parseRootPath(dir: string): string;
    /**
     * @internal
     */
    newRoot(fs: FSValue): PathWin32;
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p: string): boolean;
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
export declare class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep: '/';
    constructor(cwd?: URL | string, opts?: PathScurryOpts);
    /**
     * @internal
     */
    parseRootPath(_dir: string): string;
    /**
     * @internal
     */
    newRoot(fs: FSValue): PathPosix;
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p: string): boolean;
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
export declare class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd?: URL | string, opts?: PathScurryOpts);
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
export declare const Path: typeof PathWin32 | typeof PathPosix;
export type Path = PathBase | InstanceType<typeof Path>;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
export declare const PathScurry: typeof PathScurryWin32 | typeof PathScurryDarwin | typeof PathScurryPosix;
export type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>;
export {};
//# sourceMappingURL=index.d.ts.map