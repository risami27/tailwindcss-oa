ptor name="62791918C58049A69FA4D51EF72F68381DD90E4C" />
    </registryKey>
    <registryKey keyName="HKEY_LOCAL_MACHINE\SYSTEM\DriverDatabase\DriverPackages\mdmneuhs.inf_amd64_44b8de3f5c10d9ba\Configurations\Modem9\Driver\Init">
      <registryValue name="1" valueType="REG_SZ" value="AT&lt;cr&gt;" />
      <registryValue name="2" valueType="REG_SZ" value="AT&amp;FE0V1&amp;D2&amp;C1Q0S0=0&lt;cr&gt;" />
      <registryValue name="3" valueType="REG_SZ" value="AT+FCLASS=0&lt;cr&gt;" />
      <securityDescriptor name="62791918C58049A69FA4D51EF72F68381DD90E4C" />
    </registryKey>
    <registryKey keyName="HKEY_LOCAL_MACHINE\SYSTEM\DriverDatabase\DriverPackages\mdmneuhs.inf_amd64_44b8de3f5c10d9ba\Configurations\Modem9\Driver\LineSetPlayFormat">
      <registryValue name="1" valueType="REG_SZ" value="at+vsm=2,7200&lt;cr&gt;" />
      <securityDescriptor name="62791918C58049A69FA4D51EF72F68381DD90E4C" />
    </registryKey>
    <registryKey keyName="HKEY_LOCAL_MACHINE\SYSTEM\DriverDatabase\DriverPackages\mdmneuhs.inf_amd64_44b8de3f5c10d9ba\Configurations\Modem9\Driver\LineSetRecordFormat">
      <registryValue name="1" valueType="REG_SZ" value="at+vsm=2,7200&lt;cr&gt;" />
      <securityDescriptor name="62791918C58049A69FA4D51EF72F68381DD90E4C" />
    </registryKey>
    <registryKey keyName="HKEY_LOCAL_MACHINE\SYSTEM\DriverDatabase\DriverPackages\mdmneuhs.inf_amd64_44b8de3f5c10d9ba\Configurations\Modem9\Driver\Monitor">
      <registryValue name="1" valueType="REG_SZ" value="ATS0=0&lt;cr&gt;" />
      <registryValue name="2" valueType="REG_SZ" value="None" />
      <securityDescriptor name="62791918C58049A69FA4D51EF72F68381DD90E4C" />
    </registryKey>
    <registryKey keyName="HKEY_LOCAL_MACHINE\SYSTEM\DriverDatabase\DriverPackages\mdmneuhs.inf_amd64_44b8de3f5c10d9ba\Configurations\Modem9\Driver\Responses">
      <registryValue name="0&lt;cr&gt;" valueType="REG_BINARY" value="00000000000000000000" />
      <registryValue name="2&lt;cr&gt;" valueType="REG_BINARY" value="08000000000000000000" />
      <registryValue name="3&lt;cr&gt;" valueType="REG_BINARY" value="04000000000000000000" />
      <registryValue name="4&lt;cr&gt;" valueType="REG_BINARY" value="03000000000000000000" />
      <registryValue name="6&lt;cr&gt;" valueType="REG_BINARY" value="05000000000000000000" />
      <registryValue name="7&lt;cr&gt;" valueType="REG_BINARY" value="06000000000000000000" />
      <registryValue name="8&lt;cr&gt;" valueType="REG_BINARY" value="07000000000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;BUSY&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="06000000000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 115200/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="020200C2010000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 115200&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="020000C2010000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 1200/75&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200B004000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 1200/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202B004000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 12000/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202E02E000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 12000&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200E02E000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 1200&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200B004000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 14400/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02024038000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 14400&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02004038000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 16800/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202A041000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 16800&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200A041000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 19200&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200004B000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 21600&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02006054000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400/RLP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02026009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 24000&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200C05D000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 2400&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02006009000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 26400/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02022067000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 26400&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02002067000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 28800/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02028070000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 28800&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02008070000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 300/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02022C01000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 31200/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202E079000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 31200&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200E079000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 33600/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02024083000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 33600&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02004083000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 38400/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02020096000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 38400&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="02000096000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 4800/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C012000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 4800/RLP&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202C012000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 4800&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200C012000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 57600/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="020200E1000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 57600&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="020000E1000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 7200/REL&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0202201C000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 7200&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200201C000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 75/1200&lt;cr&gt;&lt;lf&gt;" valueType="REG_BINARY" value="0200B004000000000000" />
      <registryValue name="&lt;cr&gt;&lt;lf&gt;CONNECT 9600/REL&lt;cr&gt;&lt;lf&.kill === 'function' &&\n  typeof process.pid === 'number' &&\n  typeof process.on === 'function'\n\nconst kExitEmitter = Symbol.for('signal-exit emitter')\nconst global: typeof globalThis & { [kExitEmitter]?: Emitter } = globalThis\nconst ObjectDefineProperty = Object.defineProperty.bind(Object)\n\n/**\n * A function that takes an exit code and signal as arguments\n *\n * In the case of signal exits *only*, a return value of true\n * will indicate that the signal is being handled, and we should\n * not synthetically exit with the signal we received. Regardless\n * of the handler return value, the handler is unloaded when an\n * otherwise fatal signal is received, so you get exactly 1 shot\n * at it, unless you add another onExit handler at that point.\n *\n * In the case of numeric code exits, we may already have committed\n * to exiting the process, for example via a fatal exception or\n * unhandled promise rejection, so it is impossible to stop safely.\n */\nexport type Handler = (\n  code: number | null | undefined,\n  signal: NodeJS.Signals | null\n) => true | void\ntype ExitEvent = 'afterExit' | 'exit'\ntype Emitted = { [k in ExitEvent]: boolean }\ntype Listeners = { [k in ExitEvent]: Handler[] }\n\n// teeny special purpose ee\nclass Emitter {\n  emitted: Emitted = {\n    afterExit: false,\n    exit: false,\n  }\n\n  listeners: Listeners = {\n    afterExit: [],\n    exit: [],\n  }\n\n  count: number = 0\n  id: number = Math.random()\n\n  constructor() {\n    if (global[kExitEmitter]) {\n      return global[kExitEmitter]\n    }\n    ObjectDefineProperty(global, kExitEmitter, {\n      value: this,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    })\n  }\n\n  on(ev: ExitEvent, fn: Handler) {\n    this.listeners[ev].push(fn)\n  }\n\n  removeListener(ev: ExitEvent, fn: Handler) {\n    const list = this.listeners[ev]\n    const i = list.indexOf(fn)\n    /* c8 ignore start */\n    if (i === -1) {\n      return\n    }\n    /* c8 ignore stop */\n    if (i === 0 && list.length === 1) {\n      list.length = 0\n    } else {\n      list.splice(i, 1)\n    }\n  }\n\n  emit(\n    ev: ExitEvent,\n    code: number | null | undefined,\n    signal: NodeJS.Signals | null\n  ): boolean {\n    if (this.emitted[ev]) {\n      return false\n    }\n    this.emitted[ev] = true\n    let ret: boolean = false\n    for (const fn of this.listeners[ev]) {\n      ret = fn(code, signal) === true || ret\n    }\n    if (ev === 'exit') {\n      ret = this.emit('afterExit', code, signal) || ret\n    }\n    return ret\n  }\n}\n\nabstract class SignalExitBase {\n  abstract onExit(cb: Handler, opts?: { alwaysLast?: boolean }): () => void\n  abstract load(): void\n  abstract unload(): void\n}\n\nconst signalExitWrap = <T extends SignalExitBase>(handler: T) => {\n  return {\n    onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n      return handler.onExit(cb, opts)\n    },\n    load() {\n      return handler.load()\n    },\n    unload() {\n      return handler.unload()\n    },\n  }\n}\n\nclass SignalExitFallback extends SignalExitBase {\n  onExit() {\n    return () => {}\n  }\n  load() {}\n  unload() {}\n}\n\nclass SignalExit extends SignalExitBase {\n  // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n  // so use a supported signal instead\n  /* c8 ignore start */\n  #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP'\n  /* c8 ignore stop */\n  #emitter = new Emitter()\n  #process: ProcessRE\n  #originalProcessEmit: ProcessRE['emit']\n  #originalProcessReallyExit: ProcessRE['reallyExit']\n\n  #sigListeners: { [k in NodeJS.Signals]?: () => void } = {}\n  #loaded: boolean = false\n\n  constructor(process: ProcessRE) {\n    super()\n    this.#process = process\n    // { <signal>: <listener fn>, ... }\n    this.#sigListeners = {}\n    for (const sig of signals) {\n      this.#sigListeners[sig] = () => {\n        // If there are no other listeners, an exit is coming!\n        // Simplest way: remove us and then re-send the signal.\n        // We know that this will kill the process, so we can\n        // safely emit now.\n        const listeners = this.#process.listeners(sig)\n        let { count } = this.#emitter\n        // This is a workaround for the fact that signal-exit v3 and signal\n        // exit v4 are not aware of each other, and each will attempt to let\n        // the other handle it, so neither of them do. To correct this, we\n        // detect if we're the only handler *except* for previous versions\n        // of signal-exit, and increment by the count of listeners it has\n        // created.\n        /* c8 ignore start */\n        const p = process as unknown as {\n          __signal_exit_emitter__?: { count: number }\n        }\n        if (\n          typeof p.__signal_exit_emitter__ === 'object' &&\n          typeof p.__signal_exit_emitter__.count === 'number'\n        ) {\n          count += p.__signal_exit_emitter__.count\n        }\n        /* c8 ignore stop */\n        if (listeners.length === count) {\n          this.unload()\n          const ret = this.#emitter.emit('exit', null, sig)\n          /* c8 ignore start */\n          const s = sig === 'SIGHUP' ? this.#hupSig : sig\n          if (!ret) process.kill(process.pid, s)\n          /* c8 ignore stop */\n        }\n      }\n    }\n\n    this.#originalProcessReallyExit = process.reallyExit\n    this.#originalProcessEmit = process.emit\n  }\n\n  onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return () => {}\n    }\n    /* c8 ignore stop */\n\n    if (this.#loaded === false) {\n      this.load()\n    }\n\n    const ev = opts?.alwaysLast ? 'afterExit' : 'exit'\n    this.#emitter.on(ev, cb)\n    return () => {\n      this.#emitter.removeListener(ev, cb)\n      if (\n        this.#emitter.listeners['exit'].length === 0 &&\n        this.#emitter.listeners['afterExit'].length === 0\n      ) {\n        this.unload()\n      }\n    }\n  }\n\n  load() {\n    if (this.#loaded) {\n      return\n    }\n    this.#loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    this.#emitter.count += 1\n\n    for (const sig of signals) {\n      try {\n        const fn = this.#sigListeners[sig]\n        if (fn) this.#process.on(sig, fn)\n      } catch (_) {}\n    }\n\n    this.#process.emit = (ev: string, ...a: any[]) => {\n      return this.#processEmit(ev, ...a)\n    }\n    this.#process.reallyExit = (code?: number | null | undefined) => {\n      return this.#processReallyExit(code)\n    }\n  }\n\n  unload() {\n    if (!this.#loaded) {\n      return\n    }\n    this.#loaded = false\n\n    signals.forEach(sig => {\n      const listener = this.#sigListeners[sig]\n      /* c8 ignore start */\n      if (!listener) {\n        throw new Error('Listener not defined for signal: ' + sig)\n      }\n      /* c8 ignore stop */\n      try {\n        this.#process.removeListener(sig, listener)\n        /* c8 ignore start */\n      } catch (_) {}\n      /* c8 ignore stop */\n    })\n    this.#process.emit = this.#originalProcessEmit\n    this.#process.reallyExit = this.#originalProcessReallyExit\n    this.#emitter.count -= 1\n  }\n\n  #processReallyExit(code?: number | null | undefined) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return 0\n    }\n    this.#process.exitCode = code || 0\n    /* c8 ignore stop */\n\n    this.#emitter.emit('exit', this.#process.exitCode, null)\n    return this.#originalProcessReallyExit.call(\n      this.#process,\n      this.#process.exitCode\n    )\n  }\n\n  #processEmit(ev: string, ...args: any[]): any {\n    const og = this.#originalProcessEmit\n    if (ev === 'exit' && processOk(this.#process)) {\n      if (typeof args[0] === 'number') {\n        this.#process.exitCode = args[0]\n        /* c8 ignore start */\n      }\n      /* c8 ignore start */\n      const ret = og.call(this.#process, ev, ...args)\n      /* c8 ignore start */\n      this.#emitter.emit('exüÿÿPj j …|ıÿÿPÿµÈüÿÿ•|üÿÿĞüÿÿèmûÿÿ‹ğ…öyş €…f  3öé_  ‹¬üÿÿƒy uÇA„ ‹…Ìüÿÿº| f‹8f;:uf…ÿtf‹xf;zuƒÀƒÂf…ÿuŞ3ÀëÀƒÈ…ÀuHjXf‰…°üÿÿöA0tƒÈÿë3Àf‰…¸üÿÿ‹µ°üÿÿƒì‹ü‹KÿµÄüÿÿ¥¥¥¥ÿğ± ÿS‹ğéÊ   ‹…Ìüÿÿº  f‹8f;:uf…ÿtf‹xf;zuƒÀƒÂf…ÿuŞ3ÀëÀƒÈ…Àu(jXf‰…°üÿÿÿqÿ$° ‰…¸üÿÿ…À…{ÿÿÿ¾ €ëh‹…ÌüÿÿºÌ f‹8f;:uf…ÿtf‹xf;zuƒÀƒÂf…ÿuŞ3ÀëÀƒÈ…Àu.‹…Lüÿÿ‹IPèÉ  ‹ğ…öxjXÿµlüÿÿf‰…°üÿÿë‚¾W €ƒ½Ìüÿÿ tÿµÌüÿÿÿ° ƒ¥Ìüÿÿ ƒ½Àüÿÿ t
j jÿ° …°üÿÿPÿ° €½¤üÿÿ t|üÿÿèê  €½tüÿÿ tLüÿÿèÖ  €½xıÿÿ tPıÿÿèÂ  €½¤ıÿÿ t|ıÿÿè®  ‹Mü‹Æ_^3Í[è'4  ÉÃ‹ÿU‹ììü  ¡  3Å‰EüSV3ÀÇ…ğıÿÿ    Wf‰…Fıÿÿ‹Ú‹ù…Ìıÿÿ3É‰…ìıÿÿhş  3Ò‰@ıÿÿB‰ÌıÿÿQ…úıÿÿf‰•DıÿÿPˆôıÿÿˆ•õıÿÿè•8  …øıÿÿÇ…,ıÿÿ   ‰…(ıÿÿ3É3ÀfÇ…0ıÿÿ ƒÄ‰4ıÿÿf‰…øıÿÿ…ÿu
¾W €é  QjÿµDıÿÿÿ° ‹ğ…ötå   ·öÎ  €é×   …ıÿÿ‹ÏP•Hıÿÿè  ‹ğ…öˆ›   j •@ıÿÿ‹Ïè«  ‹ğ…öˆ‚   Q…DıÿÿP…8ıÿÿP…<ıÿÿP…ÌıÿÿPÿµ@ıÿÿ•ıÿÿHıÿÿèøÿÿ‹ğ…öxH‹•Dıÿÿ‹B0‹Èƒá…Ût…Ét3öë.ƒÈë…Étóƒàşÿµ@ıÿÿ‰B0Ìıÿÿÿµ<ıÿÿ‹•8ıÿÿè1úÿÿ‹ğj jÿ° €½0ıÿÿ tıÿÿèë  €½ôıÿÿ tÌıÿÿè×  ‹Mü‹Æ_^3Í[èP2  ÉÃ‹ÿU‹ìì   ¡  3Å‰EøSV3À‹ÚWf‰…’üÿÿ‹ñ3É…Hıÿÿj _‰…hıÿÿ3Ò…ıÿÿ‰lüÿÿj~B‰…<ıÿÿQ…vÿÿÿf‰•üÿÿP‰Hıÿÿ‰½lıÿÿˆpıÿÿˆ•qıÿÿ‰xüÿÿ‰ˆüÿÿ‰˜üÿÿ‰ıÿÿ‰½@ıÿÿˆDıÿÿˆ•Eıÿÿ‰püÿÿ‰